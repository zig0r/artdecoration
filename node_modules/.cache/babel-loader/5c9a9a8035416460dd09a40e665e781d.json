{"ast":null,"code":"/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nimport { createError, filterProps, getNamedFormat } from '../utils';\nconst DATE_TIME_FORMAT_OPTIONS = ['localeMatcher', 'formatMatcher', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'];\nexport function getFormatter({\n  locale,\n  formats,\n  onError,\n  timeZone\n}, type, getDateTimeFormat, options = {}) {\n  const {\n    format\n  } = options;\n  const defaults = Object.assign(Object.assign({}, timeZone && {\n    timeZone\n  }), format && getNamedFormat(formats, type, format, onError));\n  let filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n\n  if (type === 'time' && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second) {\n    // Add default formatting options if hour, minute, or second isn't defined.\n    filteredOptions = Object.assign(Object.assign({}, filteredOptions), {\n      hour: 'numeric',\n      minute: 'numeric'\n    });\n  }\n\n  return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value, options = {}) {\n  const date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(createError('Error formatting date.', e));\n  }\n\n  return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value, options = {}) {\n  const date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(createError('Error formatting time.', e));\n  }\n\n  return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value, options = {}) {\n  const date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(createError('Error formatting date.', e));\n  }\n\n  return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value, options = {}) {\n  const date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(createError('Error formatting time.', e));\n  }\n\n  return [];\n}","map":{"version":3,"sources":["/home/leno4ka/projects/study/artdecoration-on-reactjs/node_modules/react-intl/lib/formatters/dateTime.js"],"names":["createError","filterProps","getNamedFormat","DATE_TIME_FORMAT_OPTIONS","getFormatter","locale","formats","onError","timeZone","type","getDateTimeFormat","options","format","defaults","Object","assign","filteredOptions","hour","minute","second","formatDate","config","value","date","Date","e","String","formatTime","formatDateToParts","formatToParts","formatTimeToParts"],"mappings":"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","sourcesContent":["/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nimport { createError, filterProps, getNamedFormat } from '../utils';\nconst DATE_TIME_FORMAT_OPTIONS = [\n    'localeMatcher',\n    'formatMatcher',\n    'timeZone',\n    'hour12',\n    'weekday',\n    'era',\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'timeZoneName',\n];\nexport function getFormatter({ locale, formats, onError, timeZone, }, type, getDateTimeFormat, options = {}) {\n    const { format } = options;\n    const defaults = Object.assign(Object.assign({}, (timeZone && { timeZone })), (format && getNamedFormat(formats, type, format, onError)));\n    let filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n    if (type === 'time' &&\n        !filteredOptions.hour &&\n        !filteredOptions.minute &&\n        !filteredOptions.second) {\n        // Add default formatting options if hour, minute, or second isn't defined.\n        filteredOptions = Object.assign(Object.assign({}, filteredOptions), { hour: 'numeric', minute: 'numeric' });\n    }\n    return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting date.', e));\n    }\n    return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting time.', e));\n    }\n    return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting date.', e));\n    }\n    return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting time.', e));\n    }\n    return [];\n}\n"]},"metadata":{},"sourceType":"module"}