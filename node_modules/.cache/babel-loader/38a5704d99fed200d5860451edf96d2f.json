{"ast":null,"code":"/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nconst ESCAPED_CHARS = {\n  38: '&amp;',\n  62: '&gt;',\n  60: '&lt;',\n  34: '&quot;',\n  39: '&#x27;'\n};\nconst UNSAFE_CHARS_REGEX = /[&><\"']/g;\nexport function escape(str) {\n  return ('' + str).replace(UNSAFE_CHARS_REGEX, match => ESCAPED_CHARS[match.charCodeAt(0)]);\n}\nexport function filterProps(props, whitelist, defaults = {}) {\n  return whitelist.reduce((filtered, name) => {\n    if (name in props) {\n      filtered[name] = props[name];\n    } else if (name in defaults) {\n      filtered[name] = defaults[name];\n    }\n\n    return filtered;\n  }, {});\n}\nexport function invariantIntlContext(intl) {\n  invariant(intl, '[React Intl] Could not find required `intl` object. ' + '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport function createError(message, exception) {\n  const eMsg = exception ? `\\n${exception.stack}` : '';\n  return `[React Intl] ${message}${eMsg}`;\n}\nexport function defaultErrorHandler(error) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(error);\n  }\n}\nexport const DEFAULT_INTL_CONFIG = {\n  formats: {},\n  messages: {},\n  timeZone: undefined,\n  textComponent: React.Fragment,\n  defaultLocale: 'en',\n  defaultFormats: {},\n  onError: defaultErrorHandler\n};\nexport function createIntlCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\n\nexport function createFormatters(cache = createIntlCache()) {\n  const RelativeTimeFormat = Intl.RelativeTimeFormat;\n  const ListFormat = Intl.ListFormat;\n  const DisplayNames = Intl.DisplayNames;\n  return {\n    getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n    getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n    getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n    getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n    getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n    getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n    getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames)\n  };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n  const formatType = formats && formats[type];\n  let format;\n\n  if (formatType) {\n    format = formatType[name];\n  }\n\n  if (format) {\n    return format;\n  }\n\n  onError(createError(`No ${type} format named: ${name}`));\n}","map":{"version":3,"sources":["/home/leno4ka/projects/study/artdecoration-on-reactjs/node_modules/react-intl/lib/utils.js"],"names":["React","IntlMessageFormat","memoizeIntlConstructor","invariant","ESCAPED_CHARS","UNSAFE_CHARS_REGEX","escape","str","replace","match","charCodeAt","filterProps","props","whitelist","defaults","reduce","filtered","name","invariantIntlContext","intl","createError","message","exception","eMsg","stack","defaultErrorHandler","error","process","env","NODE_ENV","console","DEFAULT_INTL_CONFIG","formats","messages","timeZone","undefined","textComponent","Fragment","defaultLocale","defaultFormats","onError","createIntlCache","dateTime","number","relativeTime","pluralRules","list","displayNames","createFormatters","cache","RelativeTimeFormat","Intl","ListFormat","DisplayNames","getDateTimeFormat","DateTimeFormat","getNumberFormat","NumberFormat","getMessageFormat","getRelativeTimeFormat","getPluralRules","PluralRules","getListFormat","getDisplayNames","getNamedFormat","type","formatType","format"],"mappings":"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","sourcesContent":["/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nconst ESCAPED_CHARS = {\n    38: '&amp;',\n    62: '&gt;',\n    60: '&lt;',\n    34: '&quot;',\n    39: '&#x27;',\n};\nconst UNSAFE_CHARS_REGEX = /[&><\"']/g;\nexport function escape(str) {\n    return ('' + str).replace(UNSAFE_CHARS_REGEX, match => ESCAPED_CHARS[match.charCodeAt(0)]);\n}\nexport function filterProps(props, whitelist, defaults = {}) {\n    return whitelist.reduce((filtered, name) => {\n        if (name in props) {\n            filtered[name] = props[name];\n        }\n        else if (name in defaults) {\n            filtered[name] = defaults[name];\n        }\n        return filtered;\n    }, {});\n}\nexport function invariantIntlContext(intl) {\n    invariant(intl, '[React Intl] Could not find required `intl` object. ' +\n        '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport function createError(message, exception) {\n    const eMsg = exception ? `\\n${exception.stack}` : '';\n    return `[React Intl] ${message}${eMsg}`;\n}\nexport function defaultErrorHandler(error) {\n    if (process.env.NODE_ENV !== 'production') {\n        console.error(error);\n    }\n}\nexport const DEFAULT_INTL_CONFIG = {\n    formats: {},\n    messages: {},\n    timeZone: undefined,\n    textComponent: React.Fragment,\n    defaultLocale: 'en',\n    defaultFormats: {},\n    onError: defaultErrorHandler,\n};\nexport function createIntlCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {},\n    };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\nexport function createFormatters(cache = createIntlCache()) {\n    const RelativeTimeFormat = Intl.RelativeTimeFormat;\n    const ListFormat = Intl.ListFormat;\n    const DisplayNames = Intl.DisplayNames;\n    return {\n        getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n        getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n        getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n        getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n        getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n        getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n        getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames),\n    };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n    const formatType = formats && formats[type];\n    let format;\n    if (formatType) {\n        format = formatType[name];\n    }\n    if (format) {\n        return format;\n    }\n    onError(createError(`No ${type} format named: ${name}`));\n}\n"]},"metadata":{},"sourceType":"module"}